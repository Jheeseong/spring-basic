# spring-basic

# v1.10 12/27
## 웹 스코프(Scope)
### request 스코프
- 동시에 여러 HTTP 요청이 올 경우 어떤 요청이 남긴 로그인지 구분하기 위해 request 스코프를 사용
- HTTP 요청 하나가 들어오고 나갈 떄까지 유지되는 스코프.
- 각각의 HTTP 요청마다 별도의 빈 인스턴스 생성 및 관리  
- Service와 Controller MyLog로 구분하여 개발
-> 실제 고객 요청이 오지 않아 request 스코프 빈이 생성되지 않음

## 해결법
- Provider 사용
- Proxy 사용
 
### provider 사용
- ObjectProvider.getObject()를 호출하는 시점까지 request 스코프 빈 생성을 지연

### proxy 사용
- CGLIB 라이브러리로 MyLog를 상속받은 가짜 프록시 객체를 만들어 주입
- 실제 요청 시 내부에서 실제 빈을 요청
- Provider과 Proxy의 핵심은 객체 조회를 필요 시점까지 지연처리 하는 것

# v1.09 12/26
## 싱글톤과 프로토타입 빈
### 프로토타입 빈 특징
- 스프링 컨테이너 요청마다 새로 생성
- 스프링 컨테이너는 빈 생성과 의존관계 주입, 초기화까지만 관여
- 종료메서드 호출X

### 싱글톤 빈과 프로토타입 빈 사용 시 문제점
- 싱글톤 빈 내부의 프로토타입 빈은 이미 과거에 주입한 빈으로 프토로타입의 특징이 아닌 기존의 빈을 계속 사용하게 된다. -> count가 초기화되지 않고 계속 옹라간다.

### 해결 방법
- 스프링의 Provider을 사용하여 외부관계를 외부에서 주입(DI) 받는게 아닌 직접 필요한 의존관계를 찾는 것 Dependency Lookup(DL) 의존관계 조회를 한다. -> 프로토타입 빈을 직접 찾는 것으로 count 값이 초기화가 된다.

# v1.08 12/25
## 빈 생명주기 콜백
- 스프링을 통한 초기화 작업과 종료 작업을 진행

### 스프링 빈의 이벤트 라이프사이클
- 스프링 컨테이너 생성 -> 스프린 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
- 객체의 생성과 초기화를 분리해야 유지보수 관점에서 유리

### 스프링의 빈 생명주기 콜백 지원 방법
- 인터페이스(InitializingBean, DisposableBean)
- 빈 설정을 통한 초기화 메서드. 종료메서드 지정
- @PostConstruct, @PreDestroy 애노테이션 지원
  - 최근 스프링에서 @PostConstruct, @PreDestroy 애노테이션을 권장
  - 편리하며 자바 표준이라 어느 컨테이너에서든 동작
  - 컴포넌트 스캔과 어울림
  - 외부 라이브러리에는 적용 불가


# v1.07 12/25

## DI(의존관계) 시 빈이 여러 개일 경우
- 2개의 빈이 조회 될 시 NoUniqueBeanDefinitionException 오류가 발생(FixDiscountPolicy, RateDiscountPolicy)
- @Autowired 필드명 매칭, @Qualifier 매칭, @Primary 매칭으로 해결

### @Autowired 필드명 매칭
- 타입 매핑을 시도하고 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 추가 후 매칭
- 의존성 주입을 받는 필드 이름을 구현체 이름으로 명시하여 찾는 방법

### @Qualifier
- 추가 구분자를 붙여주는 방법을 제공, 빈이름 변경은 아님
- 선택되는 구현체들/ 사용 코드에 @Qualifier("찾는 이름")을 작성
- @Qualifier끼리 매칭
- 빈 이름 매칭

### @Primary
- 우선 순위를 정하는 방법, @Autowired를 통해 여러 비닝 매칭 시 @Primary가 우선권을 가짐
- @Primary는 기본 값처럼 동작하고 @Qualifier은 상세하게 동작하며 @Qualifier가 우선권을 가짐
- 조회한 빈이 모두 필요할 떄 List,Map 사용

### List,Map
- map키에 스프링 빈의 이름을 넣고 DiscountPolicy 타입으로 조회한 모든 스프링 빈을 담음
- List에 DiscountPolicy 타입으로 조회한 모든 스프링을 담음
- 선택적으로 조회한 빈을 사용 가능  
-> 자동 조회 기능을 기본으로 사용하지만 다형성을 활용하는 비지니스 로직은 수동 등록을 고민
-  직접 등록하는 기술 지원 객체는 수동 등록

# v1.06 12/23

## Compoent Scan(컴포넌트 스캔) & 의존관계 주입 시작
### 컴포넌트 스캔
- @Component를 가진 모든 대상을 가져와서 빈에 등록하기 위해 찾는 과
- @ComponentScan을 통하여 컴포넌트 애노테이션이 붙은 클래스를 스캔 후 스프링 빈에 자동 등록

#### 컴포넌트 스캔 특징
- 클래스를 스프링 빈에 등록 시 클래스명 그대로 사용하되 맨 앞글자만 소문자를 사용(빈 이름 지정 가능)
- @Contriller : 스프링 MVC 컨트롤러로 인식
- @Repository : 스프링 데이터 접근 계층으로 인식하고 데이터 계층의 예외를 스프링 예외로 변환
- @Configuration : 스프링 빈이 싱글톤을 유지하도록 처리
- @Service : 개발자들이 핵심 비지니스 계층 인식 하도록 함

#### 컴포넌트 스캔 주의점
- 컴포넌트 스캔에서 이름이 같은 클래스가 스크린 빈에 등록 될 경우 ConflictingBeanDefinitionException 예외 발생
- 수동 빈 등록과 자동 빈 등록이 충돌 될 경우 수동 빈 등록이 우선권을 가짐(수동 빈이 자동 빈을 오버라이딩) -> 스트링 부트에서 실행 시 CoreApplication 오류가 생성


## 의존관계 자동 주입
- @Autowired를 통해 의존관게 주입
  - MemoryMemberRepository, RateDiscountPolicy, MemberServiceimpl에 컴포넌트 추가
  - MemberServiceimpl, OrderServiceimpl에 Autowired 추가 

### 다양한 의존관계 주입 방법
- 생성자 주입
  - 생성자 호출 시점에 1번만 호출 보장
  - 불편,필수 의존관계에 사용(final)
  - 생성자 1개 있을 시 생략 가능

- 수정자 주입(setter 주입)
  - 선택,변경 가능성이 있는 의존관계에 사용

- 필드 주입
  - 필드에 바로 주입하는 방법
  - 외부에서 변경 불가능하여 테스드가 힘듦
  - 스프링 설정을 목표로 하는 @Configuration에서만 특별한 용도로 사용 가능

- 일반 메서드 주입
  - 한번에 여러 필드 주입 가능
  - 일반적으로 사용 X  
-> 생성자 주입 선택!!

대부분의 의존관계 주입은 일어날 시 거의 변경 X(불변)


# v1.05 12/23

## Singleton(싱글톤)
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장해주는 디자인 패턴
- 사용 이유 : 고객의 요청이 올 떄마다 **새로운 객체를 생성**하면 **메모리 낭비 문제**가 발생

### 싱글톤 적용
- static영역에 객체를 딱 하나만 생성
- 외부에서 조회가능하도록 get메서드 생성
- 생성자를 private로 생성해서 외부에서 new로 생성되는 것을 막음

### 싱글톤 단점
- 의존관계상 클라이언트가 구체 클래스에 의존 -> DIP 위반
- 클라이언트가 구체 클래스에 의존해 OCP 위반 가능성이 높음
- 내부 속성을 변경하거나 초기화에 어려움 존재

### 스프링의 싱글톤
- 스프링에서는 싱글톤의 단점을 해결하며 지원
- 기본적으로 모든 객체는 싱글톤 객체
- 스프링 컨테이너는 싱글톤 컨테이너의 역할을 하며 생성, 관리
- CGLIB라는 프록시를 사용하여 우리가 원본 클래스를 상속하는 임의의 설정 파일을 만들어서 관리

## 스프링 없는 순수한 ID 컨테이너 테스트, 싱글톤 패턴 적용 테스트, 싱글톤 컨테이너 적용 테스트 작성
- 순수 ID 컨테이너 테스트 시 고객 트래픽 마다 객체가 생성되는 문제 존재
-> 싱클톤 패턴을 적용한 코드 사용

# v1.04 12/22

## Spring Container(스프링 컨테이너)
- ApplicationContext를 통해 스프링 컨테이너 사용 가능
- 스프링 컨테이너는 **Bean을 관리**하여 **DI**를 하는 것 말고도 여러 역할이 존재
- 스프링 컨테이너는 다양한 방법(java/xml/groovy 등)으로 설정 파일 생성 가능
- 스프링 컨테이너는 **@Configuration**이 붙은 파일을 찾아서 설정 정보로 인식
- @Bean 어노테이션이 있는 모든 메서드를 호출해서 반환된 객체를 스프링 컨테이너에 등록
- 각 @Bean 간의 **의존관계를 설정**해서 사용

### BeanFactory
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역할 담당

### ApplicationContext
- BeanFactory를 상속받아 빈을 관리하는 기능을 제공
- 다양한 인터페이스들을 상속

스프링으로 전환, @Configuration, @Bean 추가

@Configuration을 통하여 Appconfig에 설정을 구성

@Bean을 통하여 스프링 컨테이너에 스프링 빈 등록

기존에는 AppConfig를 사용하여 직접 객체를 생성 및 DI하였지만 위 설정을 통해 스프링컨테이너를 통해 사용

이젠 AppConfig를 이용한 조회가 아닌 getBean()을 통해 스프링 빈(객체)를 검색

# v1.03 12/22

## IoC / DI / DI 컨테이너

### IoC(Inversion of Control)
- 제어의 역전
- 프로그램의 제어 흐름을 개발자가 아닌 프레임워크에 넘겨 작업의 구현과 수행을 분리하는 전략
- Appconfig가 제어의 흐름을 가짐

### DI(Dependency Injection)
- 의존관계 주입
- 하나의 객체가 다른 객체의 의존성을 제공하는 기술
- 정적 클래스 의존관계 / 동적 클래스 의존관계로 분리 가능
  - 정적 클래스 의존관계 : 코드만 보고도 파악 가능한 의존 관계
  - 동적 클래스 의존관계 : 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계

### ID 컨테이너
- ID를 관리하는 컨테이너

## AppConfig 추가 및 도메인, 테스트 코드 수정

- 애플리케이션의 전체 동작 방식 구성하기 위해 구현 객체 생성,연결을 책임지는 클래스 생성(관심사의 분리)
- MemberServiceImpl, MemoryMemberRepository, OrderServiceImpl, FixDiscountPolicy 구현 객체 생성
- 생성자를 통해서 레퍼런스를 연결
- AppConfig을 통해 클라이언트 코드 코드 변경 필요없이 수정 가능, 애플리케이션을 크게 사용영역과 객체를 생성하고 구성하는 영역으로 분리

-> OCP,DIP 객체지향 설계 원칙을 준수

- Appconfig 클래스를 통해 역할과 구현을 명확하게 확인 가능



# v1.02 12/22

## 좋은 객체 지향 설계의 5가지 원칙(SOLID)
- SRP(Single Reponsibility Principle) : 단일 책임 원칙
- **OCP(Open/Closed Principle) : 개방-패쇄 원칙**
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
- ISP(Interface Segregation principle) : 인터페이스 분리 원식
- **DIP(Dependency Inversion Principle) : 의존관계 역전 원칙**

### SRP(Single Reponsibility Principle)
- 한 클래스는 하나의 책임
- 핵심이 변경이 있을 떄 영향이 적어야 한다는 것(UI변경 / 객체 생성과 사용 분리 등)

### OCP(Open/Closed Principle) : 개방-패쇄 원칙
- S/W 요소는 확장에는 열려있으나 변경에는 닫혀있어야 함
- 핵심은 다형성을 활용하는 것
- 새로운 구현체를 사용한 확장은 열어두면서. 기존 코드의 변경은 닫혀있어야 함

### LSP(Liskov Substitution Principle)
- 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야함
- 다형성에서 하위 클래스는 인터페이스 규약을 지켜야 함
- 인터페이스를 구현한 구현체를 믿고 사용하려면 필요한 원칙

### ISP(Interface Segregation principle)
- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 나음
- 인터페이스가 명확해지고, 대체 가능성이 높아짐

### DIP(Dependency Inversion Principle)
- 코드가 구현클래스에 의존하지 말고, 인터페이스에 의존
- 코드는 역할에 의존
- 추상화에 의존하고, 구체화에 의존하지 말 것


## RateDiscountPolicy(새로운 정책)추가 및 테스트

### 문제점
- OCP,DIP 같은 객체지향 설계 원칙을 준수하지 못함

#### DIP

- OrderServiceImpl은 DiscountPolicy 인터페이스에 의존하면서 RateDiscountPolicy 혹은
 FixDiscountPolicy에 동시 의존
- 구현체에 의존하는 것으로 DIP에 위배

#### OCP

- 기능을 확장해서 변경하면, OrderServiceImpl에 영향
- Service 클라이언트가 구현 클래스를 직접 선택 -> 구현 객체를 변경하려면 클라이언트 코드를 변경

### 해결법

인터페이스에만 의존하도록 설계 변경 계획

## 객체지향 설계와 Spring
### Spring Framework
- Spring 이라는 Framework는 DI, DI컨테이너를 제공함으로 다형성 + OCP/DIP를 가능하게 지원

### 객체지향 설계
- 모든 설계에 역할 / 구현을 분리
- 모든 설계에 인터페이스를 부여(인터페이스는 추상화라는 비용 발생
  - 추상화 비용 : 코드를 봤을 때 인터페이스만으로 어떤 구현체를 사용했는지 알 수 없는 것

# v1.01 12/22

주문 및 할인 도메인 개발, 실행, 테스트


# v1.00 12/22
## 스프링 등장 배경
- JAVA에서 표준으로 사용하는 기술 EJB(J2EE)를 사용
  - 실제 사용 비용이 비싸 사용하기 매우 혼잡 -> spring 등장 원인
  - EJB Entity Bean(EJB에서 사용하던 ORM방식 기술) : 추후 Hibernate가 개발(JAVA표준으로 만든 것이 JPA)

## 스프링 생태계
![image](https://user-images.githubusercontent.com/96407257/150069364-3c48e526-bed3-4936-9f1f-14b042b577ca.png)  
### 필수
- 스프링 프레임 워크
  - 핵심 기술 : 스프링 DI 컨테이너/AOP 등
  - 웹 기술 : 스프링 MVC/ 스프링 WebFlux
  - 데이터 접근 기술 : transaction/ JDBC/ ORM 등
  - 기술 통합 : 캐시/ 이메일/ 스케줄링 등
  - 테스트 : 스프링 기반 테스트 지원
- 스프링 부트
  - 스프링 사용을 편리하게 지원해주는 기술
  - 단독으로 spring App을 쉽게 생성(내장 tomcat 사용)
  - 손쉬운 빌드 구성을 위한 starter 종속성 제공
  - 스프링/ third parth 라이브러리 자동 구성

### 선택
- 스프링 데이터 : 어떤 DB든 기본적인 CRUD를 제공
- 스프링 세션 : 세션 기능을 제공
- 스프링 시큐리티 : 보안관련
- restDocs : 배치 처리에 특화된 기술

## 스프링이란?
- 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크
- JAVA 언어 기반의 프레임워크 -> JAVA는 객체 지향 언어
- spring 은 JAVA의 객체 지향 언어의 장점을 살리는 프레임 워크

## 객체 지향 프로그램 이란?
- 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래핑에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 **객체**를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법

### 객체 지향 프로그램 장점
- 코드 재사용 용이 : 외부 클래스를 가져와 이용하고 상속을 통해 확장 사용 가능
- 유지 보수가 쉬움 : 수정할 부분이 클래스 내부에 맴버 변수, 혹은 메서드로 존재하여 해당 부분만 수정 가능
- 대형 프로젝트에 적합 : 클래스 단위로 모듈화 시켜 개발함으로 업무 분담이 쉬움

### 객체 지향 프로그램 단점
- 처리 속도가 상대적 느림
- 객체가 많으면 용량이 커짐
- 설계 시 많은 시간과 노력 필요

### 객체 지향 프로그래밍 키워드 5가지
- 1. 클래스 + 인스턴스(객체)
- 2. 추상화
- 3. 캡슐화
- 4. 상속
- 5. 다형성

#### 1. 클래스 + 인스턴스(객체)
- 클래스 : 솔루션 해경을 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것
- 인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리에 할당된 것

#### 2. 추상화
- 추상 클래스나 추상 메서드를 의미하기보다는 클래스 설계하는 것 자체를 의미
- **공통의**속성이나 기능을 묶어 이름을 붙이는 것

#### 3. 캡슐화
- 코드를 재수정 없이 재활용하는 것
- 접근 제어자를 통한 정보 은닉 : 객테가 외부에 노출되면 안되는 정보 또는 기능을 접근제어자를 통해 적절히 제어 권한이 있는 객테에서만 접근하도록 하여 코드 수정이 일어났을 때 책임 있는 객체만 수정하면 됨
- 관련 기능과 특성을 한 곳에 모으고 분류하기 때문에 객체 재활용이 원활

#### 4. 상속
- 부모클래스의 속성과 기능을 이어받아 사용이 가능
- 기능 일부분 수정 시 상속받은 자식클래스에서 해당 기능만 수정하여 사용 가능
- 다중 상속을 불가능

#### 5. 다형성
- 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것
- 오버라이딩 : 부모클래스를 상속받아 메서드를 재정의해서 사용하는 것
- 오버로딩 : 같은 이름의 함수를 여러 개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것
- 역활과 구현으로 구분하여 유연성을 높이고 수정이 쉬워짐(역할 - 인터페이스/ 구현 - 인터페이스를 구현한 구현 객체)
- 클라이언트는 대상의 역할(인터페이스)만 알면 됨
- 클라이언트는 구현 대상 내부 구조를 몰라도 됨
- 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향 X

## 스프링 설계

회원 도메인 개발 ,회원 저장소 개발, 회원 서비스 개발, 회원 도메인 테스트

MemoryMemberRepository에 HashMap은 동시성 이슈가 있으나 테스트를 위해 진행

MemberDomain,OrderDomain 설게의 문제점
-의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존
-> 추후 수정 예정
- OCP 원칙 DIP 원칙 무시 중
